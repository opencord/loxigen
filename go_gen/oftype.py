# Copyright 2013, Big Switch Networks, Inc.
# Copyright 2018, Red Hat, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

from collections import namedtuple
from string import Template
from generic_utils import find

import loxi_utils.loxi_utils as loxi_utils
import loxi_globals
import loxi_ir
import loxi_ir.ir as ir
import loxi_ir.ir_offset as ir_offset
import util

OFTypeData = namedtuple("OFTypeData", ["name", "serialize", "unserialize"])

def decodeClass(klass):
    return "if obj, err := Decode%s($decoder); err != nil {\nreturn nil, err\n} else {\n$member = obj\n}\n" % (klass,)

# Map from LOXI type name to an object with templates for serialize, and unserialize
# Most types are defined using the convenience code below. This dict should
# only be used directly for special cases such as primitive types.
type_data_map = {
    'char': OFTypeData(
        name='byte',
        serialize=Template('encoder.PutChar(byte($member))'),
        unserialize=Template('$member = $type($decoder.ReadChar())')),

    'uint8_t': OFTypeData(
        name='uint8',
        serialize=Template('encoder.PutUint8(uint8($member))'),
        unserialize=Template('$member = $type($decoder.ReadByte())')),

    'uint16_t': OFTypeData(
        name='uint16',
        serialize=Template('encoder.PutUint16(uint16($member))'),
        unserialize=Template('$member = $type($decoder.ReadUint16())')),

    'uint32_t': OFTypeData(
        name='uint32',
        serialize=Template('encoder.PutUint32(uint32($member))'),
        unserialize=Template('$member = $type($decoder.ReadUint32())')),

    'uint64_t': OFTypeData(
        name='uint64',
        serialize=Template('encoder.PutUint64(uint64($member))'),
        unserialize=Template('$member = $type($decoder.ReadUint64())')),

    'uint128_t': OFTypeData(
        name='uint128',
        serialize=Template('encoder.PutUint128(uint128($member))'),
        unserialize=Template('$member = $type($decoder.ReadUint128())')),

    'of_port_no_t': OFTypeData(
        name='Port',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode($decoder)')),

    'of_fm_cmd_t': OFTypeData(
        name='FmCmd',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode($decoder)')),

    'of_wc_bmap_t': OFTypeData(
        name='WcBmap',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode($decoder)')),

    'of_match_bmap_t': OFTypeData(
        name='MatchBmap',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode($decoder)')),

    'of_ipv4_t': OFTypeData(
        name='net.IP',
        serialize=Template('encoder.Write($member.To4())'),
        unserialize=Template('$member = net.IP($decoder.Read(4))')),

    'of_ipv6_t': OFTypeData(
        name='net.IP',
        serialize=Template('encoder.Write($member.To16())'),
        unserialize=Template('$member = net.IP($decoder.Read(16))')),

    'of_mac_addr_t': OFTypeData(
        name='net.HardwareAddr',
        serialize=Template('encoder.Write($member)'),
        unserialize=Template("$member = net.HardwareAddr($decoder.Read(6))")),

    'of_octets_t': OFTypeData(
        name='[]byte',
        serialize=Template('encoder.Write($member)'),
        unserialize=Template("$member = $decoder.Read($decoder.Length())")),

    'of_bitmap_128_t': OFTypeData(
        name='Bitmap128',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode($decoder)')),

    'of_oxm_t': OFTypeData(
        name='goloxi.IOxm',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template(decodeClass("Oxm"))),

    'of_checksum_128_t': OFTypeData(
        name='Checksum128',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode($decoder)')),

    'of_bitmap_512_t': OFTypeData(
        name='Bitmap512',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode($decoder)')),

    'of_time_t': OFTypeData(
        name='*Time',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template(decodeClass("Time"))),

    'of_controller_uri_t': OFTypeData(
        name='*ControllerURI',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode($decoder)')),

    'of_controller_status_entry_t': OFTypeData(
        name='*ControllerStatusEntry',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template(decodeClass('ControllerStatusEntry'))),

    'of_header_t': OFTypeData(
        name='IHeader',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template(decodeClass('Header'))),
}

## Fixed length strings

# Map from class name to length
fixed_length_strings = {
    'of_port_name_t': 16,
    'of_table_name_t': 32,
    'of_serial_num_t': 32,
    'of_desc_str_t': 256,
    'of_str64_t': 64,
}

for (cls, length) in fixed_length_strings.items():
    type_data_map[cls] = OFTypeData(
        name="string",
        serialize=Template('encoder.Write([]byte($member))'),
        unserialize=Template('$member = string(bytes.Trim($decoder.Read(%d), "\\x00"))' % length))

## Embedded structs

# Map from class name to Golang struct name
embedded_structs = {
    'of_match_t': 'Match',
    'of_nicira_match_t': 'NiciraMatch',
    'of_port_desc_t': 'PortDesc',
    'of_meter_features_t': 'MeterFeatures',
    'of_bsn_vport_t': 'BSNVport',
    'of_table_desc_t': 'TableDesc',
    'of_bsn_unit_t': 'BSNUnit',
    'ofp_bsn_module_eeprom_transceiver_t': 'BSNModuleEEPROMTransceiver',
    'of_port_desc_prop_bsn_alarm_t': 'PortDescPropBSNAlarm',
    'of_port_desc_prop_bsn_diag_t': 'PortDescProp_BSNDiag',
    'of_stat_t': 'Stat',
    'ofp_ed_prop_header_t': 'EdPropHeader',
}

for (cls, gotype) in embedded_structs.items():
    type_data_map[cls] = OFTypeData(
        name=gotype,
        serialize=Template('if err := $member.Serialize(encoder); err != nil {\n\t\treturn err\n\t}\n'),
        unserialize=Template('if err := $member.Decode($decoder); err != nil {\n\t\treturn nil, err\n\t}\n'))

## Public interface

def lookup_type_data(oftype, version):
    return type_data_map.get(loxi_utils.lookup_ir_wiretype(oftype, version))

def oftype_is_list(oftype):
    return (oftype.find("list(") == 0)

# Converts "list(of_flow_stats_entry_t)" to "of_flow_stats_entry"
def oftype_list_elem(oftype):
    assert oftype.find("list(") == 0
    return oftype[5:-3]

def oftype_get_class(oftype, version):
    if oftype in ir_offset.of_mixed_types:
        oftype = ir_offset.of_mixed_types[oftype][version.wire_version]

    oftype = oftype[:-2]
    return loxi_globals.ir[version].class_by_name(oftype)

def get_go_enum(oftype, version):
    enums = loxi_globals.ir[version].enums
    enum = find(lambda e: e.name == oftype, enums)
    if enum != None:
        return util.go_ident(oftype)

def get_go_interface(ofclass, version):
    if ofclass.name == "of_oxm":
        return "goloxi.IOxm"
    elif ofclass.name == "of_action":
        return "goloxi.IAction"
    return "I" + util.go_ident(ofclass.name)

def get_go_type(oftype, version):
    enum = get_go_enum(oftype, version)
    if enum:
        return util.go_ident(oftype)

    gotype = lookup_type_data(oftype, version)
    if not gotype and loxi_utils.oftype_is_list(oftype):
        item_type = loxi_utils.oftype_list_elem(oftype)
        klass = oftype_get_class(item_type + "_t", version)
        if klass and klass.virtual:
            gotype = "[]" + get_go_interface(klass, version)
        else:
            gotype = "[]*" + util.go_ident(item_type)
    elif gotype != None:
        gotype = gotype.name
    return gotype

def class_data_members(ofclass):
    return filter(lambda m: type(m) != ir.OFPadMember, ofclass.unherited_members)
