:: # Copyright 2013, Big Switch Networks, Inc.
:: # Copyright 2018, Red Hat, Inc.
:: #
:: # LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
:: # the following special exception:
:: #
:: # LOXI Exception
:: #
:: # As a special exception to the terms of the EPL, you may distribute libraries
:: # generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
:: # that copyright and licensing notices generated by LoxiGen are not altered or removed
:: # from the LoxiGen Libraries and the notice provided below is (i) included in
:: # the LoxiGen Libraries, if distributed in source code form and (ii) included in any
:: # documentation for the LoxiGen Libraries, if distributed in binary form.
:: #
:: # Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
:: #
:: # You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
:: # a copy of the EPL at:
:: #
:: # http://www.eclipse.org/legal/epl-v10.html
:: #
:: # Unless required by applicable law or agreed to in writing, software
:: # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
:: # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
:: # EPL for the specific language governing permissions and limitations
:: # under the EPL.
:: from loxi_globals import OFVersions
::
:: blacklisted_map_groups = ['macro_definitions']
:: blacklisted_map_idents = ['OFPFW_NW_DST_BITS', 'OFPFW_NW_SRC_BITS',
::     'OFPFW_NW_SRC_SHIFT', 'OFPFW_NW_DST_SHIFT', 'OFPFW_NW_SRC_ALL',
::     'OFPFW_NW_SRC_MASK', 'OFPFW_NW_DST_ALL', 'OFPFW_NW_DST_MASK',
::     'OFPFW_ALL']
:: include('_copyright.go')

:: include('_autogen.go')
:: import os
:: import go_gen.util as util

package ${package}

import "fmt"

:: for i, enum in enumerate(sorted(enums, key=lambda enum: enum.name)):
::     if i != 0:

::     #endif
const (
	// Identifiers from group ${enum.name}
::     for (key, value) in enum.values:
::         ident = util.go_ident(key)
::         if version == OFVersions.VERSION_1_0 and key.startswith('OFPP_'):
::             # HACK loxi converts these to 32-bit
	${ident} = ${"%#x" % (value & 0xffff)} // ${key}
::         else:
	${ident} = ${value} // ${key}
::         #endif
::     #endfor
)
::
::     if enum.params.get("wire_type", False):
::         ident = util.go_ident(enum.name)

type ${ident} ${enum.params["wire_type"][:-2]}

func (self ${ident}) MarshalJSON() ([]byte, error) {
::         keys = []
::         prefix = os.path.commonprefix([key for (key, value) in enum.values]) if len(enum.values) > 1	 else ""
::         if enum.is_bitmask:
	var flags []string
::             for (key, value) in enum.values:
	if self & ${util.go_ident(key)} == ${util.go_ident(key)} {
		flags = append(flags, "\"${util.go_ident(key[len(prefix):])}\": true")
	}
::             #endfor
	return []byte("{" + strings.Join(flags, ", ") + "}"), nil
::         elif not enum.is_bitmask and enum.params.get("complete", "") == "True":
	return []byte(fmt.Sprintf("\"%s\"", self)), nil
::         else:
	return []byte(fmt.Sprintf("%d", self)), nil
::         #endif
}
::
::         if not enum.is_bitmask and enum.params.get("complete", "") == "True":

func (self ${ident}) String() string {
	switch self {
::             for (key, value) in enum.values:
	case ${util.go_ident(key)}:
		return "${key[len(prefix):].lower()}"
::             #endfor
	default:
		return fmt.Sprintf("%d", self)
	}
}
::         #endif

::     #endif
:: #endfor
